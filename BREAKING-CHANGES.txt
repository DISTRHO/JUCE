JUCE breaking changes
=====================

Develop
=======

Version 5.3.0
=============

Change
------
The JUCE examples have been cleaned up, modernised and converted into 
PIPs (Projucer Instant Projects). The JUCE Demo has been removed and replaced by the 
DemoRunner application and larger projects such as the Audio Plugin Host and the 
Network Graphics Demo have been moved into the extras directory.

Possible Issues
---------------
1. Due to the large number of changes that have occured in the JUCE Git repository, 
pulling this version may result in a messy folder structure with empty directories 
that have been removed.
2. The JUCE Demo project is no longer in the JUCE repository.
3. The Audio Plugin Host project has moved from the examples directory to the extras
directory.

Workaround
----------
1. Run a Git clean command (git clean -xdf) in your JUCE directory to remove all untracked 
files, directories and build products.
2. The new DemoRunner application, located in extras/DemoRunner, can be used to preview
all the JUCE examples and see the code side-by-side.
3. Change any file paths that depended on the plugin host project being located in the examples
directory to use the extras directory instead.

Rationale
---------
The JUCE examples had inconsistent naming, coding styles and the projects and build products
took up a large amount of space in the repository. Replacing them with PIPs reduces the file size
and allows us to categorise the examples better, as well as cleaning up the code.


Change
------
When hosting plug-ins all AudioProcessor methods of managing parameters that
take a parameter index as an argument have been deprecated.

Possible Issues
---------------
A single assertion will be fired in debug builds on the first use of a
deprecated function.

Workaround
----------
When hosting plug-ins you should use the AudioProcessor::getParameters() method
and interact with parameters via the returned array of
AudioProcessorParameters. For a short-term fix you can also continue past the
assertion in your debugger, or temporarily modify the JUCE source code to
remove it.

Rationale
---------
Given the structure of JUCE's API it is impossible to deprecate these functions
using only compile-time messages. Therefore a single assertion, which can be
safely ignored, serves to indicate that these functions should no longer be
used. The move away from the AudioProcessor methods both improves the interface
to that class and makes ongoing development work much easier.


Change
------
This InAppPurchases class is now a JUCE Singleton. This means that you need
to get an instance via InAppPurchases::getInstance(), instead of storing a
InAppPurchases object yourself.

Possible Issues
---------------
Any code using InAppPurchases needs to be updated to retrieve a singleton pointer
to InAppPurchases.

Workaround
----------
Instead of holding a InAppPurchase member yourself, you should get an instance
via InAppPurchases::getInstance(), e.g.

instead of:

InAppPurchases iap;
iap.purchaseProduct (...);

call:

InAppPurchases::getInstance()->purchaseProduct (...);

Rationale
---------
This change was required to fix an issue on Android where on failed transaction
a listener would not get called.


Change
------
JUCE's MPE classes have been updated to reflect the official specification
recently approved by the MIDI Manufacturers Association (MMA).

Possible Issues
---------------
The most significant changes have occurred in the MPEZoneLayout classes and
programs using the higher level MPE classes such as MPEInstrument,
MPESynthesiser, MPESynthesiserBase and MPESynthesiserVoice should be
unaffected.

Previously, any MIDI channel from 1 - 15 could be selected to be the master
channel of an MPE zone, with a specified number of member channels ascending
from the master channel + 1. However, in the new specification this has been
simplified so that a device only has a lower and/or an upper zone, where the
lower zone has master channel 1 and assigns new member channels ascending from
channel 2 and the upper zone has master channel 16 and assigns new member
channels descending from channel 15.

Workaround
----------
Use the MPEZoneLayout::setLowerZone() and MPEZoneLayout::setUpperZone() methods
to set zone layouts.

Any UI that allows users to select and set zones on an MPE instrument should
also be updated to reflect the specification changes.

Rationale
---------
The MPE classes in JUCE are out of date and should be updated to reflect the
new, official MPE standard.


Version 5.2.1
=============

Change
------
Calling JUCEApplicationBase::quit() on Android will now really quit the app,
rather than just placing it in background. Starting with API level 21 (Android
5.0), the app will not appear in recent apps list after calling quit(). Prior
to API 21, the app will still appear in recent app lists but when a user
chooses the app, a new instance of the app will be started.

Possible Issues
---------------
Any code calling JUCEApplicationBase::quit() to place the app in background
will close the app instead.

Workaround
----------
Use Process::hide().

Rationale
---------
The old behaviour JUCEApplicationBase::quit() was confusing JUCE code, as a new
instance of JUCE app was attempted to be created, while the older instance was
still running in background. This would result in assertions when starting a
second instance.


Change
------
On Windows, release builds will now link to the dynamic C++ runtime by default

Possible Issues
---------------
If you are creating a new .jucer project, then your plug-in will now link to
the dynamic C++ runtime by default, which means that you MUST ensure that the
C++ runtime libraries exist on your customer's computers.

Workaround
----------
If you are only targeting Windows 10, then the C++ runtime is now part of the
system core components and will always exist on the computers of your customers
(just like kernel332.dll, for example). If you are targeting Windows versions
between Vista and Windows 10, then you should build your plug-in with the
latest updated version of VS2015 or later, which ensures that it's linked to
the universal runtime. Universal runtime is part of the system's core libraries
on Windows 10 and on Windows versions Vista to 8.1, it will be available on
your customer's computers via Windows Update. Unfortunately, if your customer
has just installed Windows 8.1 to Vista on a fresh computer, then there is a
chance that the update mechanism for the universal runtime hasn't triggered yet
and your plug-in may still fail. Your installer should prompt the user to
install all the Windows updates in this case or you can deploy the universal
runtime as a redistributable with your installer. If you are targeting earlier
versions of Windows then you should always include the runtime as a
redistributable with your plug-in's installer. Alternatively, you can change
the runtime linking to static (however, see 'Rationale' section).

Rationale
---------
In a recent update to Windows 10, Microsoft has limited the number of fiber
local storage (FLS) slots per process. Effectively, this limits how many
plug-ins with static runtime linkage can be loaded into a DAW. In the worst
case, this limits the total number of plug-ins to a maximum of 64 plug-ins.
There is no workaround for DAW vendors and the only solution is to push plug-in
vendors to use the dynamic runtime. To help with this, JUCE has decided to make
dynamic runtime linkage the default in JUCE.


Change
------
AudioProcessorGraph interface has changed in a number of ways - Node objects
are now reference counted, there are different accessor methods to iterate
them, and misc other small improvements to the API

Possible Issues
---------------
The changes won't cause any silent errors in user code, but will require some
manual refactoring

Workaround
----------
Just find equivalent new methods to replace existing code.

Rationale
---------
The graph class was extremely old and creaky, and these changes is the start of
an improvement process that should eventually result in it being broken down
into fundamental graph building block classes for use in other contexts.


Version 5.2.0
=============

Change
------
Viewport now enables "scroll on drag" mode by default on Android and iOS.

Possible Issues
---------------
Any code relying on "scroll on drag" mode being turned off by default, should
disable it manually.

Workaround
----------
None.

Rationale
---------
It is expected on mobile devices to be able to scroll a list by just a drag,
rather than using a dedicated scrollbar. The scrollbar is still available
though if needed.


Change
------
The previous setting of Android exporter "Custom manifest xml elements"
creating child nodes of <application> element has been replaced by "Custom
manifest XML content" setting that allows to specify the content of the entire
manifest instead.  Any previously values of the old setting will be used in the
new setting by default, and they will need changing as mentioned in Workaround.
The custom content will be merged with the content auto-generated by Projucer.
Any custom elements or custom attributes will override the ones set by
Projucer. Projucer will also automatically add any missing and required
elements and attributes.

Possible Issues
---------------
If a Projucer project used "Custom manifest xml elements" field, the value will
no longer be compatible with the project generated in the latest Projucer
version. The solution is very simple and quick though, as mentioned in the
Workaround section.

Workaround
----------
For any elements previously used, simply embed them explicitly in
<manifest><application> elements, for example instead of:

<meta-data android:name="paramId1" android:value="paramValue1"/>
<meta-data android:name="paramId2" android:value="paramValue2"/>

simply write:

<manifest>
<application>
<meta-data android:name="paramId1" android:value="paramValue1"/>
<meta-data android:name="paramId2" android:value="paramValue2"/>
</application>
</manifest>

Rationale
---------
To maintain the high level of flexibility of generated Android projects and to
avoid creating fields in Projucer for every possible future parameter, it is
simpler to allow to set up the required parameters manually. This way it is not
only possible to add any custom elements but it is also possible to override
the default attributes assigned by Projucer for the required elements. For
instance, if the default value of <supports-screens> element is not
satisfactory because you want a support for x-large screens only, simply set
"Custom manifest XML content" to:

<manifest>
<supports-screens android:xlargeScreens="true"/>
</manifest>


Version 5.1.2
=============

Change
------
The method used to classify AudioUnit, VST3 and AAX plug-in parameters as
either continuous or discrete has changed, and AudioUnit and AudioUnit v3
parameters are marked as high precision by default.

Possible Issues
---------------
Plug-ins: DAW projects with automation data written by an AudioUnit, AudioUnit
v3 VST3 or AAX plug-in built with JUCE version 5.1.1 or earlier may load
incorrectly when opened by an AudioUnit, AudioUnit v3, VST3 or AAX plug-in
built with JUCE version 5.1.2 and later.

Hosts: The AudioPluginInstance::getParameterNumSteps method now returns correct
values for AU and VST3 plug-ins.

Workaround
----------
Plug-ins: Enable JUCE_FORCE_LEGACY_PARAMETER_AUTOMATION_TYPE in the
juce_audio_plugin_client module config page in the Projucer.

Hosts: Use AudioPluginInstance::getDefaultNumParameterSteps as the number of
steps for all parameters.

Rationale
---------
The old system for presenting plug-in parameters to a host as either continuous
or discrete is inconsistent between plug-in types and lacks sufficient
flexibility. This change harmonises the behaviour and allows individual
parameters to be marked as continuous or discrete. If AudioUnit and AudioUnit
v3 parameters are not marked as high precision then hosts like Logic Pro only
offer a limited number of parameter values, which again produces different
behaviour for different plug-in types.


Change
------
A new FrameRateType fps23976 has been added to AudioPlayHead,

Possible Issues
---------------
Previously JUCE would report the FrameRateType fps24 for both 24 and 23.976
fps. If your code uses switch statements (or similar) to handle all possible
frame rate types, then this change may cause it to fall through.

Workaround
----------
Add fps23976 to your switch statement and handle it appropriately.

Rationale
---------
JUCE should be able to handle all popular frame rate codes but was missing
support for 23.976.


Change
------
The String (bool) constructor and operator<< (String&, bool) have been
explicitly deleted.

Possible Issues
---------------
Previous code which relied on an implicit bool to int type conversion to
produce a String will not compile.

Workaround
----------
Cast your bool to an integer to generate a string representation of it.

Rationale
---------
Letting things implicitly convert to bool to produce a String opens the door to
all kinds of nasty type conversion edge cases. Furthermore, before this change,
MacOS would automatically convert bools to ints but this wouldn't occur on
different platform. Now the behaviour is consistent across all operating
systems supported by JUCE.


Change
------
The writeAsJSON virtual method of the DynamicObject class requires an
additional parameter, maximumDecimalPlaces, to specify the maximum precision of
floating point numbers.

Possible Issues
---------------
Classes which inherit from DynamicObject and override this method will need to
update their method signature.

Workaround
----------
Your custom DynamicObject class can choose to ignore the additional parameter
if you don't wish to support this behaviour.

Rationale
---------
When serialising the results of calculations to JSON the rounding of floating
point numbers can result in numbers with 17 significant figures where only a
few are required. This change to DynamicObject is required to support
truncating those numbers.


Version 5.1.0
=============

Change
------
The option to set the C++ language standard is now located in the project
settings instead of the build configuration settings.

Possible Issues
---------------
Projects that had a specific verison of the C++ language standard set for
exporter build configurations will instead use the default (C++11) when
re-saving with the new Projucer.

Workaround
----------
Change the "C++ Language Standard" setting in the main project settings to the
required version - the Projucer will add this value to the exported project as
a compiler flag when saving exporters.

Rationale
---------
Having a different C++ language standard option for each build configuration
was unnecessary and was not fully implemented for all exporters. Changing it to
a per-project settings means that the preference will propagate to all
exporters and only needs to be set in one place.


Change
------
PopupMenus now scale according to the AffineTransform and scaling factor of
their target components.

Possible Issues
---------------
Developers who have manually scaled their PopupMenus to fit the scaling factor
of the parent UI will now have the scaling applied two times in a row.

Workaround
----------
1. Do not apply your own manual scaling to make your popups match the UI
   scaling

or

2. Override the Look&Feel method
   PopupMenu::LookAndFeelMethods::shouldPopupMenuScaleWithTargetComponent and
   return false. See
   https://github.com/WeAreROLI/JUCE/blob/c288c94c2914af20f36c03ca9c5401fcb555e4e9/modules/juce_gui_basics/menus/juce_PopupMenu.h#725

Rationale
---------
Previously, PopupMenus would not scale if the GUI of the target component (or
any of it’s parents) were scaled. The only way to scale PopupMenus was via the
global scaling factor. This had several drawbacks as the global scaling factor
would scale everything. This was especially problematic in plug-in editors.


Change
------
Removed the setSecurityFlags() method from the Windows implementation of
WebInputStream as it disabled HTTPS security features.

Possible Issues
---------------
Any code previously relying on connections to insecure webpages succeeding will
no longer work.

Workaround
----------
Check network connectivity on Windows and re-write any code that relied on
insecure connections.

Rationale
---------
The previous behaviour resulted in network connections on Windows having all
the HTTPS security features disabled, exposing users to network attacks. HTTPS
connections on Windows are now secure and will fail when connecting to an
insecure web address.


Change
------
Pointer arithmetic on a pointer will have the same result regardless if it is
wrapped in JUCE's Atomic class or not.

Possible Issues
---------------
Any code using pointer arithmetic on Atomic<T*> will now have a different
result leading to undefined behaviour or crashes.

Workaround
----------
Re-write your code in a way that it does not depend on your pointer being
wrapped in JUCE's Atomic or not. See rationale.

Rationale
---------
Before this change, pointer arithmetic with JUCE's Atomic type would yield
confusing results. For example, the following code would assert before this
change:

int* a; Atomic<int*> b;

jassert (++a == ++b);

Pointer a in the above code would be advanced by sizeof(int) whereas the JUCE's
Atomic always advances it's underlying pointer by a single byte. The same is
true for operator+=/operator-= and operator--. The difference in behaviour is
confusing and unintuitive. Furthermore, this aligns JUCE's Atomic type with
std::atomic.


Version 4.3.1
=============

Change
------
JUCE has changed the way native VST3/AudioUnit parameter ids are calculated.

Possible Issues
---------------
DAW projects with automation data written by an AudioUnit or VST3 plug-in built
with pre JUCE 4.3.1 versions will load incorrectly when opened by an AudioUnit
or VST3 built with JUCE versions 4.3.1 and later. Plug-ins using
JUCE_FORCE_USE_LEGACY_PARAM_IDS are not affected.

Workaround
----------
Disable JUCE_USE_STUDIO_ONE_COMPATIBLE_PARAMETERS in the
juce_audio_plugin_client module config page in the Projucer. For new plug-ins,
be sure to use the default value for this property.

Rationale
--------
JUCE needs to convert between its own JUCE parameter id format (strings) to the
native parameter id formats of the various plug-in backends. For VST3 and
AudioUnits, JUCE uses a hash function to generate a numeric id. However, some
VST3/AudioUnit hosts (specifically Studio One) have a bug that ignore any
parameters that have a negative parameter id. Therefore, the hash function for
VST3/AudioUnits needed to be changed to only return positive-valued hashes.


Version 4.3.0
=============

Change
------
A revised multi-bus API was released which supersedes the previously flawed
multi-bus API - JUCE versions 4.0.0 - 4.2.4 (inclusive).

Possible Issues
---------------
If you have developed a plug-in with JUCE versions 4.0.0 - 4.2.4 (inclusive),
then you will need to update your plug-in to the new multi-bus API. Pre JUCE
4.0.0 plug-ins are not affected apart from other breaking changes listed in
this document.

Woraround
---------
None.

Rationale
--------
A flawed multi-bus API was introduced with JUCE versions 4.0.0 up until version
4.2.4 (inclusive) which was not API compatible with pre JUCE 4 plug-ins. JUCE
4.3.0 releases a revised multi-bus API which restores pre JUCE 4 API
compatibility. However, the new multi-bus API is not compatible with the flawed
multi-bus API (JUCE version 4.0.0 - 4.2.4).


Change
------
JUCE now generates the AAX plug-in bus layout configuration id independent from
the position as it appears in the Projucer’s legacy "Channel layout
configuration" field.

Possible Issues
---------------
ProTools projects generated with a < 4.3.0 JUCE versions of your plug-in, may
load the incorrect bus configuration when upgrading your plug-in to >= 4.3.0
versions of JUCE.

Workaround
----------
Implement AudioProcessor’s getAAXPluginIDForMainBusConfig callback to manually
override which AAX plug-in id is associated to a specific bus layout of your
plug-in. This workaround is only necessary if you have released your plug-in
built with a version previous to JUCE 4.3.0.

Rationale
--------
The new multi-bus API offers more features, flexibility and accuracy in
specifying bus layouts which cannot be expressed by the Projucer’s legacy
"Channel layout configuration" field. The native plug-in format backends use
the new multi-bus callback APIs to negotiate channel layouts with the host -
including the AAX plug-in ids assigned to specific bus layouts. With the
callback API, there is no notion of an order in which the channel
configurations appear - as was the case with the legacy "Channel layout
configuration" field - and therefore cannot be used to generate the AAX plug-in
id. To remain backward compatible to pre JUCE 4.0.0 plug-ins, JUCE does
transparently convert the legacy "Channel layout configuration" field to the
new callback based multi-bus API, but this does not take the order into account
in which the channel configurations appear in the legacy "Channel layout
configuration" field.


Version 4.2.1
=============

Change
------
JUCE now uses the paramID property used in AudioProcessorParameterWithID to
uniquely identify parameters to the host.

Possible Issues
---------------
DAW projects with automation data written by an audio plug-in built with pre
JUCE 4.2.1 will load incorrectly when opened by an audio plug-in built with
JUCE 4.2.1 and later.

Workaround
----------
Enable JUCE_FORCE_USE_LEGACY_PARAM_IDS in the juce_audio_plugin_client module config
page in the Projucer. For new plug-ins, be sure to disable this property.

Rationale
--------
Each parameter of the AudioProcessor has an id associated so that the plug-in’s
host can uniquely identify parameters. The id has a different data-type for
different plug-in types (for example VST uses integers, AAX uses string
identifiers). Before 4.2.1, JUCE generated the parameter id by using the index
of the parameter, i.e. the first parameter had id zero, the second parameter
had id one, etc. This caused problems for certain plug-in types where JUCE
needs to add internal parameters to the plug-in (for example VST3 requires the
bypass control to be a parameter - so JUCE automatically creates this parameter
for you in the VST3 backend). This causes subtle problems if a parameter is
added to an update of an already published plug-in. The new parameter’s id
would be identical to the id of the bypass parameter in old versions of your
plug-in, causing seemingly random plug-in bypass behaviour when user’s upgrade
their plug-in.

Most plug-in backends differentiate between a parameter’s id an index, so this
distinction was adopted starting with JUCE 4.2.1 by deriving the parameter’s
unique id from the paramID property of AudioProcessorParameterWithID class.
